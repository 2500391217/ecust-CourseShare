# **第4部分**  **存储器管理**

学习重点：

##### 1. 存储器管理的功能：

内存分配、地址映射、内存保护、内存扩充。



##### 2. 内存以字节为单位进行编址，CPU按内存中的地址读出内存中的内容。



##### 3. 用户程序的主要处理阶段：

 编辑、编译、链接（三种方式）、装入（三种方式）、运行。

程序的链接：
	·静态链接方式：对相对地址进行修改，变换外部调用符号
	·装入时动态链接：可分开存放，便于修改更新、实现对目标模块的共享
	·运行时动态链接：只将用到的模块调入内存，并链接

程序的装入：
	·绝对装入方式：适用于单道程序环境，绝对（物理）地址
	·**可重定位装入方式**：多道程序环境下，地址变换只在装入内存时一次完成，以后不再改变（静态重定位）。
		重定位——在装入时 对**目标程序**中指令和数据的地址进行修改的过程
	·**动态运行时的装入方式**：不在装入时做地址转换，而是到程序运行时才做。因此，装入内存后的所有地址都是逻辑地址。需要**重定位寄存器**的支持。



##### 4. 相对地址、绝对地址、重定位（静态重定位和动态重定位）的概念（地址重定位的对象是目标程序）、内存碎片。

​	==静态重定位在进程装入内存时进行==，装入程序==直接将指令和数据地址都变换成物理地址==再装入到内存，**缺点在于**所有的地址都变成了绝对地址==程序装入到内存之后不能再移动，而且地址必须连续分配==	P133

​	==动态重定位在程序执行时进行，==在装入程序时==直接把页装入相应的内存==，当执行到这段指令时再进行地址映射（==边运行边地址映射==），比较灵活，但是缺点在于==需要硬件支持（一个记录为其分配的内存起始地址的寄存器，重定位时只需要在这之上加上偏移量就行）==	P133

​	==也就是说代码装入内存是原封不动地装入内存的。==



##### 5. 内存的连续分配方式(不管离散连续我们讲的都是一次性装入)：

​	一种是连续（特点是==一次性==:全部装入内存且整个运行完毕之后才能退出，缺点是==有碎片==）、一种是离散（为了解决碎片才引入的离散）：

​	一下都是连续的（连续分为固定和可变）：

​	单一连续分配方式：单道程序环境下，系统区（内存低址）、用户区

​	固定分区分配方式：多道程序，划分固定大小区域（存储空间浪费）

​	动态分区分配方式：内存分配和回收（4种情况，按照回收区的位置分配）
​		分配算法：
​		·基于**顺序搜索**的动态分区分配算法
​			==首次适应算法==—将空闲分区**按地址顺序递增**从小到大登记在空闲分区表中；（常见）
​			循环首次适应算法—**按地址顺序**接上一次往下找
​			==最佳适应算法==—将空闲分区**按容量大小大小递增**的顺序登记在空闲分区表中；（常见）
​			最坏适应算法--将空闲分区**按长度大小递减**的顺序登记在空闲分区表中
​		·基于**索引搜索**的动态分区分配算法
​			快速适应算法
​			伙伴系统：多处理机系统中
​			哈希算法

​	动态可重定位分区分配方式（采用**移动/紧凑**的技术）。



##### 6. 内存回收时的四种情况。



##### 7. 内存的==离散分配方式==：

​	基本==分页==存储管理方式、基本==分段==存储管理方式、==段页==式存储管理方式。



##### 8. 基本分页存储管理方式：

​	基本原理：==把进程的虚拟地址空间划分成若干4K大小的页，把内存也划分成若干4K大小的块，保证一个逻辑页对应一个物理块，从而解决碎片问题，实现离散分配（需要地址映射引入页表）。==

​	页面32（页是信息的物理单位）地址机构（一维的，由页号和页内地址组成）

​	物理块22（块号、块内地址）

​	页框、页表（页号、块号，页表在内存中，页表功能由一组寄存器完成）

​	地址变换机构（能够画出地址变换图、会把逻辑地址转换成物理地址）

​	==没有快表（即联想存储器）的情况下访问一条指令或取得一个数据需2次访问内存（一次访问页表，一次根据物理地址取得指令或数据）==

​	具有快表（联想存储器）的地址变换机构，具有联想存储器时根据命中率计算数据访问内存的有效时间。

​	T = a(Treg + Ts) + (1-a)(Treg + 2Ts)

​	两级和多级页表：10*n + 12



##### 9. 基本分段存储管理方式：

​	基本原理

​	段（==段是信息的逻辑单位，每个段定义了一组逻辑信息==）

​	地址结构（二维的，由段号和段内地址组成）

​	段表（段号、段长、基址）

​	地址变换机构（能够画出地址变换图**P158**、会把逻辑地址转换成物理地址）

​	访问一条指令或取得一个数据需2次访问内存（一次访问段表，一次根据物理地址取得指令或数据）

​	分段和分页的区别**P93**（物理/逻辑，大小固定/不固定，地址空间一维/二维）

​	==段式存储管理**易于实现信息的共享**、便于扩充、进行保护禁止非法访问(存取控制字段)==（以段为单位分配一块连续的内存空间，段的长度可以不同，段和段之间可以占用不连续的内存空间）。



##### 10. 段页式存储管理方式：

​	基本原理

​	段表（一个用户进程有一个段表）

​	页表（用户进程有几段就有几个页表）

​	地址变换机构（怎样从逻辑地址转换为物理地址？）

​	==访问一条指令或取得一个数据需3次访问内存（一次访问段表，一次访问该段所对应的页表，一次根据物理地址取得指令或数据）。==









##### 11. 虚拟存储器：定义、特征、虚拟存储器的实现方式：

​	==内存空间有限但想提高并发度于是在逻辑上扩充。==

​	==虚拟存储器可管理的空间直接取决于**CPU中地址寄存器的位数**。==

​	定义：具有**请求调入功能**和**置换功能**，能从**逻辑上对内存容量加以扩充**的一种存储器系统。

​	虚拟存储器可管理的空间直接取决于**处理器中地址寄存器的位数，**逻辑容量为内存和外存容量之和，速度接近内存，成本接近外存

​	特征：==虚拟的扩充==、==多次性(缺页中断，多次装入)==、==离散分配==、==对换性==、虚拟性

​	实现方法：==请求分页系统(重点掌握这个就行)==、请求分段系统、请求段页系统



##### 12. 请求分页存储管理：

​	在基本分页存储管理基础上增加了**请求调页功能**和**页面置换功能**

​	如果访问的指令数据不在内存中就缺页中断，缺页中断的处理过程(如果内存有空闲块就直接从外存调入并修改页表，如果没有就页面置换)

​	**必需的硬件支持**有：请求分页的页表机制（对页表进行了扩充，访问位、修改位的作用）、缺页中断机构、地址变换机构。



##### 13. 请求分页存储管理中的==页面置换算法==：

​	最佳置换算法（OPT）

​	先进先出页面置换算法（FIFO）--会产生Belady异常现象

​	最近最久未使用置换算法（LRU）

​	Clock页面置换算法

​	能够根据以上几种页面置换算法计算缺页次数和缺页率。

​	另外，改进型Clock页面置换算法中页表的访问位A=0、修改位M=0的页面表示该页最近既未被访问，又未被修改，是最佳淘汰页。

​	**抖动：**频繁更换页面，以致一个进程在运行中把大部分时间都花费在页面置换工作上，则称该进程发生了“抖动”。
​	Belady现象：缺页率过高时，系统会采用全局分配，多给该进程分配一些物理块，直到缺页率降下来。 



##### 14. 请求分段存储管理：

​	在基本分段存储管理基础上增加了**请求调段功能**和**段的置换功能**

​	必需的硬件支持有：请求分段的段表机制、缺段中断机构、地址变换机构。

​	三个中断处理机制：分 段越界、分段保护、缺段

​	三种**分段保护措施**：地址越界检查、存取控制检查、环保护机制



##### 15. 虚拟段页式存储管理。

 